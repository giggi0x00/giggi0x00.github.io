<!DOCTYPE html>
<html class="" lang="en-us"><head>
    
        <script>
            if (location.host != new URL("https:\/\/giggi0x00.github.io\/").host) location.href = "https:\/\/giggi0x00.github.io\/"
        </script>
    
    <meta name="robots" content="noai, noimageai">
    <meta name="viewport" content="width=device-width" />
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=7" />

    <link
    rel="icon"
    href='/favicon.png'
/>
<link
    rel="shortcut icon"
    href='/favicon.ico'
    type="image/x-icon"
/>
<link
    rel="apple-touch-icon"
    href='/apple-touch-icon.png'
/>

    <link
        rel="icon"
        href='/logo.svg'
        type="image/svg+xml"
    />

<title>
        
            Reverse Engineering Radio Signals: The Gnu Radio Way  &ndash;
        
        giggi0x00hub
    </title>

    <link href="/symbols-nerd-font/symbols-nerd-font.css" rel="stylesheet" />
    <link href="/jetbrains-mono/jetbrains-mono.css" rel="stylesheet" />

    
    
    <link type="text/css" rel="stylesheet" href=https://giggi0x00.github.io/css/styles.11dd9b4f8e754057ce9e5c871170129bd0727d375643f3c7b3ea1cebc8a713bc0f506e4b359cade525b588692555ecfb93e267b9c03ea713c6c958a883527803.css integrity="sha512-Ed2bT451QFfOnlyHEXASm9ByfTdWQ/PHs&#43;oc68inE7wPUG5LNZyt5SW1iGklVez7k&#43;JnucA&#43;pxPGyViog1J4Aw==" />
<meta name="author" content="Luigi Fragale" />

    
    
        <meta name="description" content="ER: This write-up is based on the original solution created by the author of the Hammingbird radio-signal CTF challenge &lt;a href=&#34;https://aleand.ro/2025/09/24/hamming-bird-ctrl-space-ctf/&#34;&gt;you can find it here&lt;/a&gt;. Many thanks to @aleand.ro. The purpose of this exercise is to redesign the solution using GNU Radio solely for the purpose of learning more about radio signals, exploring the tool, and having fun. This blog post is written with passion, dedication and a lot of hours debugging GNU Radio.&lt;/em&gt;&lt;/p&gt;" />
    

<meta property="og:site_name"
    content='giggi0x00hub' />

    <meta property="og:title" content="Reverse Engineering Radio Signals: The Gnu Radio Way" />
    <meta property="og:type" content="article" />
    
    <meta
        property="article:author" content="Luigi Fragale" />
    <meta
        property="article:published_time"
        content='2025-11-18T04:10:42Z&#43;0000' />
    
    <meta property="og:url" content="https://giggi0x00.github.io/posts/radio-signal-ctf/" />
    
    
    <meta property="og:image"
        content="https://giggi0x00.github.io/android-chrome-512x512.png" />
    
        <meta property="og:description" content="&lt;hr&gt;
&lt;p&gt;&lt;em&gt;DISCLAIMER: This write-up is based on the original solution created by the author of the Hammingbird radio-signal CTF challenge &lt;a href=&#34;https://ale" />
    

<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:domain"
      content='giggi0x00.github.io'
/>
<meta property="twitter:url" content="https://giggi0x00.github.io/posts/radio-signal-ctf/" />


    <meta name="twitter:title" content="Reverse Engineering Radio Signals: The Gnu Radio Way" />
    
    
    
    <meta name="twitter:image"
        content="https://giggi0x00.github.io/android-chrome-512x512.png" />
    
        <meta name="twitter:description" content="&lt;hr&gt;
&lt;p&gt;&lt;em&gt;DISCLAIMER: This write-up is based on the original solution created by the author of the Hammingbird radio-signal CTF challenge &lt;a href=&#34;https://ale" />
    

<link rel="manifest" href="/manifest/index.json" />
</head>


<body>
        <div id="baseContainer"><header class="">
<div class="titleAndSearchContainer">
        <div id="titleContainer">
            
                <a class="unstyledLink" href="/">
                    <img src='/logo.svg' alt='Logo'/>
                </a>
            
            <div class="rightOfLogo">
                <div class="titleAndHamburger">
                    <h1>
                        <a class="unstyledLink" href="/">giggi0x00hub</a>
                        
                    </h1>
                    
                </div>
                <div id="wide_nav"><nav>
    
    <ul id="main-nav">
        <li><a href="/">Home</a></li>
        
            <li><a href="/posts/">Posts</a></li>
        
        
        
        
        
            <li><a href="https://giggi0x00.github.io/pages/about/">
                About
            </a></li>
        
        
        
        
    </ul>
</nav>
</div>
            </div>
        </div>
        <div class="search">
    <input id="searchbar" type="text" placeholder='Search' />
    <span class="nerdlink" onclick="newSearch();">&#xf002;</span>
</div>
<script>
    function newSearch() {
        let term = searchbar.value.trim();
        if (!term) return;
        location.href = `/search/?q=${term}`;
    }
    searchbar.onkeyup = (ev) => {if (ev.keyCode == 13) newSearch()};
</script>

    </div>
    <div id="links">
        
        
        <a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://github.com/giggi0x00">
    
    
        &#xf09b;
    
    <span>
        GitHub
    </span>
</a>
<a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://www.linkedin.com/in/luigi-fragale/">
    
    
        &#xf0e1;
    
    <span>
        LinkedIn
    </span>
</a>

    </div>
    

</header>
<div id="contentContainer">
                <div id="content">
                    <main>
<article class="card single">
    
        <h1>Reverse Engineering Radio Signals: The Gnu Radio Way</h1>
    
    
        <p class="date">
            <span title='Date'>󰃭 </span>
    2025-11-18

</p>
    
    
    
    
    <div><hr>
<p><em>DISCLAIMER: This write-up is based on the original solution created by the author of the Hammingbird radio-signal CTF challenge <a href="https://aleand.ro/2025/09/24/hamming-bird-ctrl-space-ctf/">you can find it here</a>. Many thanks to @aleand.ro. The purpose of this exercise is to redesign the solution using GNU Radio solely for the purpose of learning more about radio signals, exploring the tool, and having fun. This blog post is written with passion, dedication and a lot of hours debugging GNU Radio.</em></p>
<p>For those who are not familiar with GNU Radio, you can find a clear and concise explanation here: <a href="https://wiki.gnuradio.org/index.php?title=What_Is_GNU_Radio">https://wiki.gnuradio.org/index.php?title=What_Is_GNU_Radio</a></p>
<hr>
<h3 id="challenge-description">Challenge Description</h3>
<p>The <code>Hamming Bird</code> radio-signal CTF challenge is part of the <code>Ctrl-Space CTF 2025</code>, a unique cybersecurity competition played on real satellites orbiting Earth. The goal of the challenge is to reverse-engineer the radio signal to uncover a secret message hidden within the broadcast transmission.</p>
<blockquote>
<p>A flying bird is transmitting some telemetry data; check if any important information has been broadcast!</p>
</blockquote>
<p>In offline radio-signal challenges, the player is typically given a complex file captured from radio transmissions. In this case, the input provided is the file <code>rf-dump.complex</code>. The extension already hints that the file could contain a radio signal representation.</p>
<p>Let&rsquo;s load the file into GNU Radio using the <code>File Source</code> block and observe the frequency span with the <code>QT GUI Frequency Sink</code>. Initially, we can set the sample rate to a high value such as 100k. This value should match the expected bandwidth, allowing us to load the entire signal into the frequency spectrum for observation.</p>
<p><img src="/images/firstblock.png" alt="QT GUI Frequency Sink"></p>
<p><img src="/images/output.gif" alt="QT GUI Frequency Sink"></p>
<p>As we can see from the frequency plot, the signal is not centered, and two distinct frequency peaks are clearly visible. This is a good indication that the transmitted frequency changes over time, suggesting that an FSK modulation scheme may be used.
This behavior can be further examined using the <code>QT GUI Waterfall Sink</code> in GNU Radio or with Inspectrum, which visualizes how frequency evolves over time.</p>
<p><img src="/images/inspectrum.gif" alt="QT GUI Frequency Sink"></p>
<p>We can already a spot a recurrent pattern at the beginning of the transmission, that is called preamble and it is very common in radio frequency signals. The preamble is a fixed, repetitive sequence sent by the transmitter to wake up the receiver and synchronize it to the correct bit rate. This sequence is usually something simple and known, such as <code>1010101010101</code>, and it marks the beginning of the transmission.</p>
<p>While Inspectrum can already help already with some basic demodulation it is still limited in signal processing, therefore, from now on we will use Gnu Radio.</p>
<h3 id="lets-start">Let&rsquo;s start!</h3>
<p>We begin with filtering and re-centering the signal to make later processing steps easier. For this task, we use a frequency-translating FIR filter. This block takes two main inputs: a <em>taps</em> function and a <em>center frequency</em>.</p>
<p>While the center frequency parameter is straightforward, the taps function can be less intuitive. In simple terms, the taps define the filter characteristics, for example, the low cutoff, high cutoff, or both, determine which frequency components are allowed to pass through. <em>Many others parameters are described in the documentation <a href="https://wiki.gnuradio.org/index.php/Frequency_Xlating_FIR_Filter">here</a></em>.</p>
<p><img src="/images/low-pass-filter-and-center.png" alt="Frequency Xltaing FIR Filter"></p>
<p>The FIR filter produces a new signal, shown below in the first waterfall plot:</p>
<p><img src="/images/filtering.gif" alt="Filtering"></p>
<p>At the top, we see a cleaner signal where only the relevant frequencies are passed through.</p>
<p>As observed earlier, we identified that the signal uses FSK modulation, more specifically <strong>2-FSK</strong>, based on the two peaks visible in the Frequency Sink. GNU Radio provides a demodulation block called <a href="https://wiki.gnuradio.org/index.php/Quadrature_Demod">Quadrature Demod</a>. <em>Although it is not designed only for 2-FSK, it can be configured appropriately for that purpose</em>.</p>
<p>In particular, setting the <code>Gain</code> parameter to: <code>samp_rate / (2 * math.pi * fsk_deviation)</code> results in correct FSK demodulation. Refer to the documentation for a deeper explanation of how this value is derived.</p>
<p>Plotting the output of the <code>Quadrature Demod</code> block reveals an almost “squared” signal, although it is not yet fully clean:</p>
<p><img src="/images/post-mod.gif" alt="Filtering"></p>
<p>As we can see, we can have already a good view on the demodulated signal and we can already spot some recurring patterns, such as the preamble we previously observed in Inspectrum.</p>
<p>So far, we haven&rsquo;t achieved much more than previously done via Inspectrum, but it is here that Gnu Radio comes into place.</p>
<h3 id="gnu-radio-post-processing">Gnu Radio Post-Processing</h3>
<p>GNU Radio can further refine this signal for better processing, one useful block for this purpose is the <a href="https://wiki.gnuradio.org/index.php/Moving_Average">Moving Average</a> block. It improves signal squaring but more specifically it performs an average of the value in a specific interval taking out noise.</p>
<p>See below the plotted output:
<img src="/images/aftermovingav.png" alt="After Moving Average"></p>
<p>That basically completed the demodulation part, an in theory we could stop here and do further processing off Gnu Radio with a python script for example, but I want to provide an extra mile that made my life a bit easier when working with this signal and perhaps can help me in the future while dealing with similar transmissions.</p>
<h3 id="messages-extraction-and-preamble-identification">Messages Extraction and Preamble Identification</h3>
<p>One additional step I wanted to implement for this CTF challenge was a reliable method to automatically detect each message, save it as an individual file, and process it independently.</p>
<p>To perform this type of splitting, we can use three modules :</p>
<ul>
<li><a href="https://wiki.gnuradio.org/index.php/Burst_Tagger">Burst Tagger</a></li>
<li><a href="https://wiki.gnuradio.org/index.php/Tagged_File_Sink">Tagged File Sink</a></li>
<li><a href="https://wiki.gnuradio.org/index.php/Complex_to_Mag">Complex to Mag</a></li>
</ul>
<p>We can use the magnitude of a signal to identify noise and then tag the sample where the noise start or finish. <em>(It may not be the best way to do so but I found it very handy for this case)</em></p>
<p><img src="/images/tagging-blocks.png" alt="Packets Identification"></p>
<p><img src="/images/tagg-live.gif" alt="Tagging Live"></p>
<p>This approach becomes very powerful when searching for specific messages or when building post-acquisition routines that operate on a per-packet basis. For example, GNU Radio supports custom Python modules to process each packet, using tagged samples to determine the start and end of a transmission.</p>
<p>Below is an example of a post-processing function that handles tagged samples and processes each captured packet individually:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>[<span style="color:#ff79c6">...</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">work</span>(<span style="font-style:italic">self</span>, input_items, output_items):
</span></span><span style="display:flex;"><span>        inp <span style="color:#ff79c6">=</span> input_items[<span style="color:#bd93f9">0</span>]
</span></span><span style="display:flex;"><span>        n <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">len</span>(inp)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Build dictionary of tags at positions</span>
</span></span><span style="display:flex;"><span>        tags <span style="color:#ff79c6">=</span> <span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>get_tags_in_window(<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, n)
</span></span><span style="display:flex;"><span>        tag_positions <span style="color:#ff79c6">=</span> {t<span style="color:#ff79c6">.</span>offset <span style="color:#ff79c6">-</span> <span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>nitems_read(<span style="color:#bd93f9">0</span>): t <span style="color:#ff79c6">for</span> t <span style="color:#ff79c6">in</span> tags}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(n):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4"># ---------------------------</span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4"># TAG HANDLING</span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4"># ---------------------------</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> i <span style="color:#ff79c6">in</span> tag_positions:
</span></span><span style="display:flex;"><span>                t <span style="color:#ff79c6">=</span> tag_positions[i]
</span></span><span style="display:flex;"><span>                key <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">str</span>(t<span style="color:#ff79c6">.</span>key)
</span></span><span style="display:flex;"><span>                val <span style="color:#ff79c6">=</span> pmt<span style="color:#ff79c6">.</span>to_python(t<span style="color:#ff79c6">.</span>value)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4"># DEBUG PRINT</span>
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;Tag:&#34;</span>, key, <span style="color:#f1fa8c">&#34;Value:&#34;</span>, val)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4"># START BURST</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> key <span style="color:#ff79c6">==</span> <span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>tag_key <span style="color:#ff79c6">and</span> val <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>:
</span></span><span style="display:flex;"><span>                    <span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>in_burst <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">True</span>
</span></span><span style="display:flex;"><span>                    <span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>current_buf <span style="color:#ff79c6">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4"># END BURST</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">elif</span> key <span style="color:#ff79c6">==</span> <span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>tag_key <span style="color:#ff79c6">and</span> val <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>:
</span></span><span style="display:flex;"><span>                    <span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>in_burst <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4"># Convert to numpy array</span>
</span></span><span style="display:flex;"><span>                    burst <span style="color:#ff79c6">=</span> np<span style="color:#ff79c6">.</span>array(<span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>current_buf, dtype<span style="color:#ff79c6">=</span>np<span style="color:#ff79c6">.</span>float32)
</span></span><span style="display:flex;"><span>                    <span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>saved_bursts<span style="color:#ff79c6">.</span>append(burst)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>processed_bursts<span style="color:#ff79c6">.</span>append(burst)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;Captured packet length:&#34;</span>, <span style="color:#8be9fd;font-style:italic">len</span>(burst))
</span></span><span style="display:flex;"><span>                    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Packets captured</span><span style="color:#f1fa8c">{</span><span style="color:#8be9fd;font-style:italic">len</span>(<span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>processed_bursts)<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>) 
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">#print(&#34;Packet&#34;)</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">#print(burst);</span>
</span></span><span style="display:flex;"><span>                    <span style="font-style:italic">self</span><span style="color:#ff79c6">.</span>parse(burst)
</span></span></code></pre></div><p>In a nutshell, the Python block detects the preamble and uses the provided threshold parameter for similarity estimation. It then decodes the packet using the Hamming algorithm and prints the payload to the screen. The full output is available on Gnu Radio in the console window.</p>
<p><img src="/images/python-processing.gif" alt="Python Block"></p>
<p>The entire code can be found on my Github repository <a href="https://github.com/giggi0x00/Radio_Signal_CTF_Ctrl-Space_CTF_2025">https://github.com/giggi0x00/Radio_Signal_CTF_Ctrl-Space_CTF_2025</a>.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Although I was unable to complete the challenge within the allocated time during the CTF, I continued working on it afterward to learn more about radio signals and, in particular, the GNU Radio tool, which can help speed up signal processing without reinventing the wheel. Thank you for making it this far! Happy hacking!</p>
</div>
</article>






                    </main><footer>
    <hr />

<p><small>
        2025 &copy; Luigi Fragale - <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
    </small></p>
    <p><small>
        
    </small></p>
</footer>
</div>
            </div>
        </div>


</body>
</html>
